#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );

#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );

#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );

#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );

#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );

#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );

#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );

#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );

#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );

#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );

#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );




#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );



#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );


#include "mdx.h"
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// READLEN % 64 must = 0
#define READLEN    1048576L // 2^20, 1MB

void DigestFile( char * );
void DigestString();

void main(int argc, char *argv[])
{
    printf("%s\n\n", MDxGetVersion());

    if( argc > 1 )
        DigestFile( argv[1] );
    else    
        DigestString();

}

/*
    I use the 'chunk' method for processing files not because of
    limitations of my dll, but think what would happen if you
    tried to load an entire cd image into memory.
*/
void DigestFile( char *szFName )
{
    FILE *file;
    void *lpData;
    long flen, mlen;
    MDxSum mdDataSum;
    MDxSum md4DataSum;

    // the 64 is for padding purposes
    lpData = malloc( READLEN + 64 );
    
    printf( "MD4/5 Digests of \"%s\":\n", szFName );

    file = fopen( szFName, "rb" );
    if( file == NULL )
    {
        printf("ERROR: File not found.\n");
        return;
    }
    
    MDxInit( &mdDataSum );
    MDxInit( &md4DataSum );
    
    fseek( file, 0, SEEK_END );
    //Get the file length
    flen = mlen = ftell( file );
    fseek( file, 0, SEEK_SET );
    
    // When it takes a while to process a large file,
    // remember that for each chunk it has to run 
    // through the main translation loop 16384 times!
        
    printf("Processing %ld byte file: .", flen );
    
    while( flen > READLEN )
    {
        if( fread( lpData, 1, READLEN, file ) != READLEN)
        {
            printf("READ ERROR!\n");
            return;
        }
        MD5Translate( lpData, READLEN, &mdDataSum );
        MD4Translate( lpData, READLEN, &md4DataSum );
        flen -= READLEN;
        printf(".");
    }

    if (fread( lpData, 1, flen, file ) != flen)
    {
        printf("READ ERROR!\n");
        return;
    }
    // This is why I added the new argument to MDxPad
    // So we can pass the length of the data AND the
    // Total length of the message
    // Also it now returns the # of padding bytes added,
    // this is for files that are an exact multiple of the chunk
    // length. (Otherwise the padding isn't Translated)
    flen += MDxPad( lpData, flen, mlen );
    MD5Translate( lpData, flen, &mdDataSum );    
    MD4Translate( lpData, flen, &md4DataSum );

    // New step necessary because of the 'chunking' method
    MDxFinalize( &mdDataSum );
    MDxFinalize( &md4DataSum );
    
    printf("\nMD4: %08x%08x%08x%08x\n", md4DataSum.dwSum[0], md4DataSum.dwSum[1], md4DataSum.dwSum[2], md4DataSum.dwSum[3]);
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    fclose(file);
        
}

void DigestString()
{
    
    //For our demo purposes, no strings bigger than 1024 :)
    unsigned char lpData[1024] = "";
    long len = 0;
    MDxSum mdDataSum;

    printf("Enter the string to digest: ");
    scanf("%s", &lpData );
    len = strlen(lpData);
    
    // Have to do this before the Padding...well...it's best anyway;)
    printf( "MD4/5 Digests of \n\"%s\":\n", lpData );
    
    // For the strings, we're gonna pad and digest the string
    // in one pass.
    MDxInit( &mdDataSum );
    MDxPad( lpData, len, len );
    
    MD5Translate( lpData, len, &mdDataSum );
        // New step necessary because of the 'chunking' method
        MDxFinalize( &mdDataSum );
    printf("MD5: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);
    
    MDxInit( &mdDataSum );
    MD4Translate( lpData, len, &mdDataSum );    
    printf("MD4: %08x%08x%08x%08x\n", mdDataSum.dwSum[0], mdDataSum.dwSum[1], mdDataSum.dwSum[2], mdDataSum.dwSum[3]);

    return;
}


-------------- Include

#ifndef __windows_h__
        typedef unsigned long DWORD;
        #define STDCALL _stdcall
#endif

typedef struct 
{
    DWORD dwSum[4];
}MDxSum;

DWORD STDCALL MDxPad ( unsigned char *, unsigned long, unsigned long );
void STDCALL MDxInit( MDxSum * );
void STDCALL MD5Translate( unsigned char *, long, MDxSum * );
void STDCALL MD4Translate( unsigned char *, long, MDxSum * );
const char * STDCALL MDxGetVersion();
void STDCALL MDxFinalize( MDxSum * );